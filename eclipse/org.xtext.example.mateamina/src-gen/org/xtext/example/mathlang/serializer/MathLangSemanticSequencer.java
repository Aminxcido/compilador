/*
 * generated by Xtext 2.38.0
 */
package org.xtext.example.mathlang.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mathlang.mathLang.Assignment;
import org.xtext.example.mathlang.mathLang.DelimitedExpr;
import org.xtext.example.mathlang.mathLang.Div;
import org.xtext.example.mathlang.mathLang.FunctionCall;
import org.xtext.example.mathlang.mathLang.MathLangPackage;
import org.xtext.example.mathlang.mathLang.Minus;
import org.xtext.example.mathlang.mathLang.Model;
import org.xtext.example.mathlang.mathLang.Mul;
import org.xtext.example.mathlang.mathLang.Negative;
import org.xtext.example.mathlang.mathLang.NumberLiteral;
import org.xtext.example.mathlang.mathLang.Plus;
import org.xtext.example.mathlang.mathLang.Pow;
import org.xtext.example.mathlang.mathLang.Variable;
import org.xtext.example.mathlang.services.MathLangGrammarAccess;

@SuppressWarnings("all")
public class MathLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MathLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MathLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MathLangPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MathLangPackage.DELIMITED_EXPR:
				sequence_DelimitedExpr(context, (DelimitedExpr) semanticObject); 
				return; 
			case MathLangPackage.DIV:
				sequence_MulDiv(context, (Div) semanticObject); 
				return; 
			case MathLangPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case MathLangPackage.MINUS:
				sequence_AddSub(context, (Minus) semanticObject); 
				return; 
			case MathLangPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MathLangPackage.MUL:
				sequence_MulDiv(context, (Mul) semanticObject); 
				return; 
			case MathLangPackage.NEGATIVE:
				sequence_Unary(context, (Negative) semanticObject); 
				return; 
			case MathLangPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case MathLangPackage.PLUS:
				sequence_AddSub(context, (Plus) semanticObject); 
				return; 
			case MathLangPackage.POW:
				sequence_Pow(context, (Pow) semanticObject); 
				return; 
			case MathLangPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Minus
	 *     SimpleExpression returns Minus
	 *     AddSub returns Minus
	 *     AddSub.Plus_1_0_0_0 returns Minus
	 *     AddSub.Minus_1_0_1_0 returns Minus
	 *     MulDiv returns Minus
	 *     MulDiv.Mul_1_0_0_0 returns Minus
	 *     MulDiv.Div_1_0_1_0 returns Minus
	 *     Pow returns Minus
	 *     Pow.Pow_1_0 returns Minus
	 *     Unary returns Minus
	 *     Primary returns Minus
	 *
	 * Constraint:
	 *     (left=AddSub_Minus_1_0_1_0 right=MulDiv)
	 * </pre>
	 */
	protected void sequence_AddSub(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddSubAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddSubAccess().getRightMulDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Plus
	 *     SimpleExpression returns Plus
	 *     AddSub returns Plus
	 *     AddSub.Plus_1_0_0_0 returns Plus
	 *     AddSub.Minus_1_0_1_0 returns Plus
	 *     MulDiv returns Plus
	 *     MulDiv.Mul_1_0_0_0 returns Plus
	 *     MulDiv.Div_1_0_1_0 returns Plus
	 *     Pow returns Plus
	 *     Pow.Pow_1_0 returns Plus
	 *     Unary returns Plus
	 *     Primary returns Plus
	 *
	 * Constraint:
	 *     (left=AddSub_Plus_1_0_0_0 right=MulDiv)
	 * </pre>
	 */
	protected void sequence_AddSub(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddSubAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddSubAccess().getRightMulDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Assignment
	 *     Assignment returns Assignment
	 *     SimpleExpression returns Assignment
	 *     AddSub returns Assignment
	 *     AddSub.Plus_1_0_0_0 returns Assignment
	 *     AddSub.Minus_1_0_1_0 returns Assignment
	 *     MulDiv returns Assignment
	 *     MulDiv.Mul_1_0_0_0 returns Assignment
	 *     MulDiv.Div_1_0_1_0 returns Assignment
	 *     Pow returns Assignment
	 *     Pow.Pow_1_0 returns Assignment
	 *     Unary returns Assignment
	 *     Primary returns Assignment
	 *
	 * Constraint:
	 *     (left=Variable right=Expression)
	 * </pre>
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.ASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.ASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.ASSIGNMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.ASSIGNMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getLeftVariableParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DelimitedExpr returns DelimitedExpr
	 *
	 * Constraint:
	 *     expr=Expression
	 * </pre>
	 */
	protected void sequence_DelimitedExpr(ISerializationContext context, DelimitedExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.DELIMITED_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.DELIMITED_EXPR__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDelimitedExprAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns FunctionCall
	 *     SimpleExpression returns FunctionCall
	 *     AddSub returns FunctionCall
	 *     AddSub.Plus_1_0_0_0 returns FunctionCall
	 *     AddSub.Minus_1_0_1_0 returns FunctionCall
	 *     MulDiv returns FunctionCall
	 *     MulDiv.Mul_1_0_0_0 returns FunctionCall
	 *     MulDiv.Div_1_0_1_0 returns FunctionCall
	 *     Pow returns FunctionCall
	 *     Pow.Pow_1_0 returns FunctionCall
	 *     Unary returns FunctionCall
	 *     Primary returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             func='sin' | 
	 *             func='cos' | 
	 *             func='tan' | 
	 *             func='sqrt' | 
	 *             func='log' | 
	 *             func='ln' | 
	 *             func='frac'
	 *         ) 
	 *         (args+=Expression args+=Expression*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     expressions+=DelimitedExpr+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Div
	 *     SimpleExpression returns Div
	 *     AddSub returns Div
	 *     AddSub.Plus_1_0_0_0 returns Div
	 *     AddSub.Minus_1_0_1_0 returns Div
	 *     MulDiv returns Div
	 *     MulDiv.Mul_1_0_0_0 returns Div
	 *     MulDiv.Div_1_0_1_0 returns Div
	 *     Pow returns Div
	 *     Pow.Pow_1_0 returns Div
	 *     Unary returns Div
	 *     Primary returns Div
	 *
	 * Constraint:
	 *     (left=MulDiv_Div_1_0_1_0 right=Pow)
	 * </pre>
	 */
	protected void sequence_MulDiv(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulDivAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulDivAccess().getRightPowParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Mul
	 *     SimpleExpression returns Mul
	 *     AddSub returns Mul
	 *     AddSub.Plus_1_0_0_0 returns Mul
	 *     AddSub.Minus_1_0_1_0 returns Mul
	 *     MulDiv returns Mul
	 *     MulDiv.Mul_1_0_0_0 returns Mul
	 *     MulDiv.Div_1_0_1_0 returns Mul
	 *     Pow returns Mul
	 *     Pow.Pow_1_0 returns Mul
	 *     Unary returns Mul
	 *     Primary returns Mul
	 *
	 * Constraint:
	 *     (left=MulDiv_Mul_1_0_0_0 right=Pow)
	 * </pre>
	 */
	protected void sequence_MulDiv(ISerializationContext context, Mul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.MUL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.MUL__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.MUL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.MUL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulDivAccess().getMulLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulDivAccess().getRightPowParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     SimpleExpression returns NumberLiteral
	 *     AddSub returns NumberLiteral
	 *     AddSub.Plus_1_0_0_0 returns NumberLiteral
	 *     AddSub.Minus_1_0_1_0 returns NumberLiteral
	 *     MulDiv returns NumberLiteral
	 *     MulDiv.Mul_1_0_0_0 returns NumberLiteral
	 *     MulDiv.Div_1_0_1_0 returns NumberLiteral
	 *     Pow returns NumberLiteral
	 *     Pow.Pow_1_0 returns NumberLiteral
	 *     Unary returns NumberLiteral
	 *     Primary returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Pow
	 *     SimpleExpression returns Pow
	 *     AddSub returns Pow
	 *     AddSub.Plus_1_0_0_0 returns Pow
	 *     AddSub.Minus_1_0_1_0 returns Pow
	 *     MulDiv returns Pow
	 *     MulDiv.Mul_1_0_0_0 returns Pow
	 *     MulDiv.Div_1_0_1_0 returns Pow
	 *     Pow returns Pow
	 *     Pow.Pow_1_0 returns Pow
	 *     Unary returns Pow
	 *     Primary returns Pow
	 *
	 * Constraint:
	 *     (base=Pow_Pow_1_0 exponent=Pow)
	 * </pre>
	 */
	protected void sequence_Pow(ISerializationContext context, Pow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.POW__BASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.POW__BASE));
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.POW__EXPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.POW__EXPONENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowAccess().getPowBaseAction_1_0(), semanticObject.getBase());
		feeder.accept(grammarAccess.getPowAccess().getExponentPowParserRuleCall_1_2_0(), semanticObject.getExponent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Negative
	 *     SimpleExpression returns Negative
	 *     AddSub returns Negative
	 *     AddSub.Plus_1_0_0_0 returns Negative
	 *     AddSub.Minus_1_0_1_0 returns Negative
	 *     MulDiv returns Negative
	 *     MulDiv.Mul_1_0_0_0 returns Negative
	 *     MulDiv.Div_1_0_1_0 returns Negative
	 *     Pow returns Negative
	 *     Pow.Pow_1_0 returns Negative
	 *     Unary returns Negative
	 *     Primary returns Negative
	 *
	 * Constraint:
	 *     operand=Unary
	 * </pre>
	 */
	protected void sequence_Unary(ISerializationContext context, Negative semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.NEGATIVE__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.NEGATIVE__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryAccess().getOperandUnaryParserRuleCall_0_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Variable
	 *     SimpleExpression returns Variable
	 *     AddSub returns Variable
	 *     AddSub.Plus_1_0_0_0 returns Variable
	 *     AddSub.Minus_1_0_1_0 returns Variable
	 *     MulDiv returns Variable
	 *     MulDiv.Mul_1_0_0_0 returns Variable
	 *     MulDiv.Div_1_0_1_0 returns Variable
	 *     Pow returns Variable
	 *     Pow.Pow_1_0 returns Variable
	 *     Unary returns Variable
	 *     Primary returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathLangPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathLangPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
